import algorithms.graphs.GridPositioning;
import com.yworks.yfiles.algorithms.*;
import com.yworks.yfiles.geometry.PointD;
import com.yworks.yfiles.geometry.Matrix2D;
import com.yworks.yfiles.geometry.RectD;
import com.yworks.yfiles.geometry.SizeD;
import com.yworks.yfiles.graph.*;
import com.yworks.yfiles.graph.styles.PolylineEdgeStyle;
import com.yworks.yfiles.graph.styles.ShinyPlateNodeStyle;
import com.yworks.yfiles.graph.styles.SimpleLabelStyle;
import com.yworks.yfiles.layout.GraphTransformer;
import com.yworks.yfiles.layout.OperationType;
import com.yworks.yfiles.layout.YGraphAdapter;
import com.yworks.yfiles.layout.circular.CircularLayout;
import com.yworks.yfiles.layout.organic.OrganicLayout;
import com.yworks.yfiles.layout.organic.OrganicRemoveOverlapsStage;
import com.yworks.yfiles.layout.orthogonal.OrthogonalLayout;
import com.yworks.yfiles.layout.tree.TreeLayout;
import com.yworks.yfiles.view.*;
import com.yworks.yfiles.view.export.CanvasPrintable;
import com.yworks.yfiles.view.export.ContextConfigurator;
import com.yworks.yfiles.view.export.PixelImageExporter;
import com.yworks.yfiles.view.input.*;
import io.ChristianIOHandler;
import io.SergeyIOHandler;
import layout.algo.*;
import algorithms.graphs.MinimumAngle;
import layout.algo.MinimumAngleImprovement;
import layout.algo.event.AlgorithmEvent;
import layout.algo.event.AlgorithmListener;
import layout.algo.GridDrawing;
import util.RandomGraphGenerator;
import util.*;
import util.interaction.*;
import util.graph2d.*;
import util.graph2d.LineSegment;

import javax.swing.*;
import javax.swing.filechooser.FileFilter;

import java.awt.*;
import java.awt.event.*;
import java.awt.print.PrinterException;
import java.awt.print.PrinterJob;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.time.Duration;
import java.util.*;
import java.util.stream.*;
import java.util.List;
import java.util.function.*;


/**
 * Created by michael on 28.10.16.
 */
public class MainFrame extends JFrame {

    /* Graph Drawing related objects */
    private GraphComponent view;
    private IGraph graph;
    private OrganicLayout defaultLayouter;
    private GraphEditorInputMode graphEditorInputMode;
    private GridVisualCreator gridVisualCreator;
    private GraphSnapContext graphSnapContext;
    private boolean isGridVisible;

    /* Default Styles */
    private ShinyPlateNodeStyle defaultNodeStyle;
    private PolylineEdgeStyle defaultEdgeStyle;
    private SimpleLabelStyle defaultLabelStyle;

    /* Object that keeps track of the latest open/saved file */
    private String fileNamePath;
    private String fileNamePathFolder;

    /* Central gui elements */
    private JLabel infoLabel;
    private JProgressBar progressBar;

    private JPanel sidePanel;
    private int sidePanelFirstY = 0, sidePanelNextY;

    private GeneticAlgorithm<ForceAlgorithmApplier> geneticAlgorithm;
    private Thread geneticAlgorithmThread;
    final double Epsilon = 0.01;
    final Function<PointD, PointD> rotate = (p -> new PointD(p.getY(), -p.getX()));
    private boolean perpendicular = true;
    private boolean createNodeAllowed = true;
    private boolean optimizingNinty = true;
    JSlider[] sliders;




    private Maybe<ForceAlgorithmApplier> faa = Maybe.nothing();

    public static final Consumer<Maybe<ForceAlgorithmApplier>> finalizeFAA = Maybe.lift(f -> {
        f.running = false;
        f.clearDrawables();
    });

    /**
     * Creates new form MainFrame
     */
    public MainFrame() {
        this.initComponents();
        this.initMenuBar();

        super.setTitle("Graph Drawing Tool");
        super.setMinimumSize(new Dimension(400, 300));
        super.setExtendedState(MAXIMIZED_BOTH);
        super.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
        super.addWindowListener(new WindowAdapter() {
            public void windowClosing(WindowEvent evt) {
                System.exit(0);
            }
        });
    }


    /**
     * This method is called within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {

        JPanel progressBarPanel = new JPanel();
        progressBarPanel.setLayout(new GridLayout(1, 2, 10, 10));

        this.infoLabel = new JLabel();
        this.infoLabel.setText("Number of Vertices: 0     Number of Edges: 0");
        progressBarPanel.add(infoLabel);

        this.progressBar = new JProgressBar();
        this.progressBar.setPreferredSize(new Dimension(250, 20));
        this.progressBar.setStringPainted(true);
        progressBarPanel.add(this.progressBar);

        JPanel mainPanel = new JPanel();
        mainPanel.setBorder(BorderFactory.createEmptyBorder(10, 10, 10, 10));
        mainPanel.setPreferredSize(new Dimension(300, 300));
        //mainPanel.setLayout(new BorderLayout(0, 10));
        mainPanel.setLayout(new GridBagLayout());
        GridBagConstraints c = new GridBagConstraints();
        c.fill = GridBagConstraints.HORIZONTAL;
        c.gridy = 2;
        c. insets = new Insets(5, 0, 5, 0);
        mainPanel.add(progressBarPanel, c);
        //mainPanel.add(progressBarPanel, BorderLayout.PAGE_END);

        this.view = new GraphComponent();
        this.view.setSize(330, 330);
        this.view.requestFocus();
        c.fill = GridBagConstraints.BOTH;
        c.gridy = 1;
        c.weightx = 0.8;
        mainPanel.add(this.view, c);
        //mainPanel.add(this.view, BorderLayout.CENTER);

        this.graph = this.view.getGraph();
        this.graph.setUndoEngineEnabled(true);

        this.graphEditorInputMode = new GraphEditorInputMode();
        this.graphEditorInputMode.setCreateNodeAllowed(true);
        this.graphEditorInputMode.setCreateEdgeAllowed(true);
        this.graphEditorInputMode.setCreateBendAllowed(true);
        this.graphEditorInputMode.setEditLabelAllowed(true);
        this.graphEditorInputMode.addPopulateItemPopupMenuListener((o, iModelItemPopulateItemPopupMenuEventArgs) -> {
            if (iModelItemPopulateItemPopupMenuEventArgs.getItem() instanceof INode) {
                populateNodePopupMenu(iModelItemPopulateItemPopupMenuEventArgs);
            }
            if (iModelItemPopulateItemPopupMenuEventArgs.getItem() instanceof IEdge) {
                populateEdgePopupMenu(iModelItemPopulateItemPopupMenuEventArgs);
            }
        });
        this.view.setInputMode(this.graphEditorInputMode);

        /* Add four listeners two the graph */
        this.graph.addNodeCreatedListener((o, iNodeItemEventArgs) -> {
            graph.addLabel(iNodeItemEventArgs.getItem(), Integer.toString(graph.getNodes().size() - 1));
            this.graph.setStyle(iNodeItemEventArgs.getItem(), this.defaultNodeStyle.clone());
            this.graph.setStyle(iNodeItemEventArgs.getItem().getLabels().first(), this.defaultLabelStyle.clone());
            infoLabel.setText("Number of Vertices: " + graph.getNodes().size() + "     Number of Edges: " + graph.getEdges().size());
        });

        this.graph.addEdgeCreatedListener((o, iNodeItemEventArgs) -> {
            this.graph.setStyle(iNodeItemEventArgs.getItem(), this.defaultEdgeStyle.clone());
            infoLabel.setText("Number of Vertices: " + graph.getNodes().size() + "     Number of Edges: " + graph.getEdges().size());
        });
        this.graph.addNodeRemovedListener((o, iNodeItemEventArgs) -> {
            infoLabel.setText("Number of Vertices: " + graph.getNodes().size() + "     Number of Edges: " + graph.getEdges().size());
        });

        this.graph.addEdgeRemovedListener((o, iNodeItemEventArgs) -> {
            infoLabel.setText("Number of Vertices: " + graph.getNodes().size() + "     Number of Edges: " + graph.getEdges().size());
        });

        this.graph.addNodeLayoutChangedListener((o, u, iNodeItemEventArgs) -> {
            MinimumAngle.resetHighlighting(this.graph);
            faa.andThen(f -> {
                f.clearDrawables();
                f.resetNodePosition(u);
            });
        });

        /* Add two listeners two the graph */
        this.graphSnapContext = new GraphSnapContext();
        this.graphEditorInputMode.setSnapContext(this.graphSnapContext);
        GridInfo gridInfo = new GridInfo();
        this.gridVisualCreator = new GridVisualCreator(gridInfo);
        this.view.getBackgroundGroup().addChild(this.gridVisualCreator, ICanvasObjectDescriptor.ALWAYS_DIRTY_INSTANCE);
        this.isGridVisible = true;
        this.graphSnapContext.setGridSnapType(GridSnapTypes.GRID_POINTS);
        this.graphSnapContext.setNodeGridConstraintProvider(new GridConstraintProvider<>(gridInfo));
        this.graphSnapContext.setBendGridConstraintProvider(new GridConstraintProvider<>(gridInfo));

       /* Default Styling of Nodes, Edges and Labels */
       DefaultStyling defStyle = new DefaultStyling(this.graph);

        super.getContentPane().setLayout(new java.awt.BorderLayout(20, 20));
        super.getContentPane().add(mainPanel, java.awt.BorderLayout.CENTER);
        //super.getContentPane().add(mainPanel, c);

        c.gridy = 0;
        c.fill = GridBagConstraints.HORIZONTAL;
        c. insets = new Insets(5, 0, 10, 0);
        //mainPanel.add(toolBar, BorderLayout.PAGE_START);

        this.defaultLayouter = new OrganicLayout();
        this.defaultLayouter.setPreferredEdgeLength(100);
        this.defaultLayouter.setMinimumNodeDistance(100);

        Tuple3<JPanel, JSlider[], Integer> slidPanelSlidersCount = ThresholdSliders.create(springThreshholds, new String[]{"Spring force", "Electrical force", "Crossing force", "Incident edges force"});
        this.sidePanel = slidPanelSlidersCount.a;
        this.sliders = slidPanelSlidersCount.b;
        sidePanelNextY = slidPanelSlidersCount.c;
        c.gridy = 1;
        c.gridx = 1;
        c.weighty = 1;
        c.weightx = 0.2;
        c.insets = new Insets(0, 0, 0, 0);
        c.fill = GridBagConstraints.VERTICAL;
        mainPanel.add(sidePanel, c);
        //mainPanel.add(sliders, BorderLayout.LINE_END);
        GridBagConstraints cSidePanel = new GridBagConstraints();
        //WARNING: POST-INCREMENT!
        cSidePanel.gridy = sidePanelNextY++;
        JButton startGenetic = new JButton("Start genetic algo"), 
                stopGenetic  = new JButton("Stop genetic algo");
        startGenetic.addActionListener(this::startGeneticClicked);
        stopGenetic.addActionListener(this::stopGeneticClicked);

        sidePanel.add(startGenetic, cSidePanel);
        cSidePanel.gridx = 1;
        sidePanel.add(stopGenetic, cSidePanel);
        cSidePanel.gridy = sidePanelNextY++;
        JRadioButton forceDirectionPerpendicular = new JRadioButton("Perpendicular"),
                forceDirectionNonPerpendicular = new JRadioButton("Non Perpendicular");
        cSidePanel.gridx = 0;
        sidePanel.add(forceDirectionPerpendicular,cSidePanel);
        forceDirectionPerpendicular.setSelected(true);
        forceDirectionPerpendicular.addActionListener(this::forceDirectionPerpendicularActionPerformed);
        cSidePanel.gridx = 1;
        sidePanel.add(forceDirectionNonPerpendicular,cSidePanel);
        forceDirectionNonPerpendicular.setSelected(false);
        forceDirectionNonPerpendicular.addActionListener(this::forceDirectionNonPerpendicularActionPerformed);

        ButtonGroup group = new ButtonGroup();
        group.add(forceDirectionNonPerpendicular);
        group.add(forceDirectionPerpendicular);

        JRadioButton optimizingAngleNinty = new JRadioButton("Optimizing Angle Crossing: 90°"),
                optimizingAngleSixty = new JRadioButton("Optimizing Angle Crossing: 60°");

        cSidePanel.gridy = sidePanelNextY++;
        cSidePanel.gridx = 0;
        sidePanel.add(optimizingAngleNinty,cSidePanel);
        optimizingAngleNinty.setSelected(true);
        optimizingAngleNinty.addActionListener(this::optimizingAngleNintyActionPerformed);
        cSidePanel.gridx = 1;
        sidePanel.add(optimizingAngleSixty,cSidePanel);
        optimizingAngleSixty.setSelected(false);
        optimizingAngleSixty.addActionListener(this::optimizingAngleSixtyActionPerformed);

        ButtonGroup angleGroup = new ButtonGroup();
        angleGroup.add(optimizingAngleNinty);
        angleGroup.add(optimizingAngleSixty);

        cSidePanel.gridy = sidePanelNextY++;
        cSidePanel.gridx = 0;
        JButton startForce = new JButton("Start force algo"),
                stopForce  = new JButton("Stop force algo");
        startForce.addActionListener(this::startForceClicked);
        stopForce.addActionListener(this::stopForceClicked);

        sidePanel.add(startForce, cSidePanel);
        cSidePanel.gridx = 1;
        sidePanel.add(stopForce, cSidePanel);

        cSidePanel.gridy = sidePanelNextY++;
        cSidePanel.gridx = 0;
        JButton showForces = new JButton("Show forces");
        showForces.addActionListener(e -> {
            if(!faa.hasValue()){
                faa = Maybe.just(defaultForceAlgorithmApplier(0));
            }
            faa.get().showForces();
        });
        sidePanel.add(showForces, cSidePanel);

        cSidePanel.gridx = 1;
        JButton showBestSolution = new JButton("Show best");
        showBestSolution.addActionListener(e -> {
            ForceAlgorithmApplier.bestSolution.andThen( nm_mca_da_ba -> {
                IMapper<INode, PointD> nodePositions = nm_mca_da_ba.a;
                Maybe<Double> minCrossingAngle = nm_mca_da_ba.b;
                Double[] mods = nm_mca_da_ba.c;
                Boolean[] switchs = nm_mca_da_ba.d;
                ForceAlgorithmApplier.applyNodePositionsToGraph(graph, nodePositions);
                String msg = minCrossingAngle.fmap(d -> "Minimum crossing angle: " + d.toString()).getDefault("No crossings!");
                msg += "\n";
                msg += "Modifiers:\n";
                for(int i = 0; i < mods.length; i++){
                    Double d = mods[i];
                    sliders[i].setValue((int) (1000 * d));
                    msg += "\t" + d.toString() + "\n";
                }
                msg += "\n";
                msg += "Switches:\n";
                for(Boolean b: switchs){
                    msg += "\n\t" + b.toString() + "\n";
                }
                JOptionPane.showMessageDialog(null, msg);
            });
        });
        sidePanel.add(showBestSolution, cSidePanel);
    }


    public static Random rand = new Random();
    public void initializeGeneticAlgorithm(){
        geneticAlgorithm = GeneticAlgorithm.<ForceAlgorithmApplier>newGeneticAlgorithm_FunGen(
            (faa -> {
                faa.runNoDraw();
                return faa;
            }),
            ((faa1, faa2) -> {
                Maybe<Double> ma1 = MinimumAngle.getMinimumAngle(graph, Maybe.just(faa1.nodePositions)),
                              ma2 = MinimumAngle.getMinimumAngle(graph, Maybe.just(faa2.nodePositions));
                if(ma1.hasValue() && !ma2.hasValue()){
                    return -1;
                }
                if(!ma1.hasValue() && ma2.hasValue()){
                    return 1;
                }
                if(!ma1.hasValue() && !ma2.hasValue()){
                    return 0;
                }
                Double a1 = ma1.get(),
                       a2 = ma2.get();
                return a1.compareTo(a2);
            }),
            20,
            (fa -> {
                IMapper<INode, PointD> nodePositions = ForceAlgorithmApplier.copyNodePositionsMap(fa.nodePositions, graph.getNodes().stream());

                List<Tuple3<LineSegment, LineSegment, Intersection>> crossings = MinimumAngle.getCrossingsSorted(graph, Maybe.just(nodePositions));
                ForceAlgorithmApplier fa2 = fa.clone();
                if(crossings.size() == 0) {
                    return fa2;
                }

                List<Tuple3<LineSegment, LineSegment, Intersection>> mostInteresting = crossings.subList(0, (int) Math.ceil(crossings.size() / 50.0));

                //random choice
                //int nodeIndex = rand.nextInt(graph.getNodes().size());
                //INode node = graph.getNodes().getItem(nodeIndex);
                INode node = null;
                int nodeDegree = Integer.MAX_VALUE;
                Tuple3<LineSegment, LineSegment, Intersection> nodeCrossing = null;
                int whichNode = -1;

                //random crossing
                int crossingIndex = rand.nextInt(mostInteresting.size());
                nodeCrossing = mostInteresting.get(crossingIndex);
                whichNode = rand.nextInt(4);
                INode[] nodes = new INode[]{
                    nodeCrossing.a.n1.get(),
                    nodeCrossing.a.n2.get(),
                    nodeCrossing.b.n1.get(),
                    nodeCrossing.b.n2.get()
                };
                node = nodes[whichNode];

                if(node == null || nodeCrossing == null || whichNode < 0){
                    // ??? This CAN'T happen. Compiler thinks it can, but it can't.
                    return fa2;
                }
                //PointD pos = nodePositions.getValue(node);
                PointD pos = nodeCrossing.c.intersectionPoint;
                PointD direction = new PointD(0, 0);
                switch(whichNode){
                    case 0: direction = PointD.negate(nodeCrossing.b.ve);
                            break;
                    case 1: direction = nodeCrossing.b.ve;
                            break;
                    case 2: direction = PointD.negate(nodeCrossing.a.ve);
                            break;    
                    case 3: direction = nodeCrossing.a.ve;
                            break;
                }
                if(nodeCrossing.c.orientedAngle > 90){
                    direction = PointD.negate(direction);
                }
                if(direction.getVectorLength() <= Epsilon){
                    return fa2;
                }
                direction = direction.getNormalized();
                PointD posOld = pos;
                pos = PointD.add(pos, PointD.times(fa.modifiers[2], direction));
                nodePositions.setValue(node, pos);
                fa2.nodePositions = nodePositions;

                // russian roulette to change a modifier
                if(fa2.modifiers.length > 0 && rand.nextDouble() > 0.5){
                    // randomly modify one spring threshhold
                    int modIndex = rand.nextInt(fa.modifiers.length);
                    // smallest double > 0
                    double minVal = Math.nextAfter(0, Double.POSITIVE_INFINITY);
                    // value should remain 0 < val <= 1
                    fa2.modifiers[modIndex] = Math.min(1, Math.max(minVal, fa.modifiers[modIndex] * rand.nextDouble() * 2));
                }

                // russian roulette to change a switch
                if(fa2.switches.length > 0 && rand.nextDouble() > 0.5){
                    // randomly modify one spring threshhold
                    int switchIndex = rand.nextInt(fa.switches.length);
                    // smallest double > 0
                    double minVal = Math.nextAfter(0, Double.POSITIVE_INFINITY);
                    // value should remain 0 < val <= 1
                    fa2.switches[switchIndex] = (fa.switches[switchIndex] == false);
                }
                return fa2;
            }));
        geneticAlgorithm.bestChanged = Maybe.just(faa -> {
            faa.draw(graph);
            view.updateUI();
        });
        ForceAlgorithmApplier fa = defaultForceAlgorithmApplier(250);
        geneticAlgorithm.instances.add(fa);
        geneticAlgorithmThread = new Thread(geneticAlgorithm);
    }

    public void startGeneticClicked(ActionEvent e){
        if(geneticAlgorithm == null || geneticAlgorithm.running == false){
            ForceAlgorithmApplier.init();
            initializeGeneticAlgorithm();
        this.graphEditorInputMode.setCreateNodeAllowed(false);
            geneticAlgorithmThread.start();
        }
    }


    public void stopGeneticClicked(ActionEvent e){
        geneticAlgorithm.running = false;
        this.graphEditorInputMode.setCreateNodeAllowed(true);
    }

    public void startForceClicked(ActionEvent e){
        if(!faa.hasValue() || faa.get().running == false){
            ForceAlgorithmApplier.init();
            ForceAlgorithmApplier fd = defaultForceAlgorithmApplier(-1);
            fd.modifiers = springThreshholds;
            fd.switches = algoModifiers;
            MainFrame.finalizeFAA.accept(faa);
            faa = Maybe.just(fd);
            Thread thread = new Thread(fd);
        this.graphEditorInputMode.setCreateNodeAllowed(false);
            thread.start();
            this.view.updateUI();
        }
    }

    public void stopForceClicked(ActionEvent e){
        faa.andThen(f -> {
            f.running = false;
            this.graphEditorInputMode.setCreateNodeAllowed(true);
        });
        
    }

    private void initMenuBar() {
        JMenuBar mainMenuBar = new JMenuBar();
        JMenu layoutMenu = new JMenu();
        JMenu viewMenu = new JMenu();

        InitMenuBar menuBar = new InitMenuBar(mainMenuBar, layoutMenu, viewMenu, this.graph, this.infoLabel, this.view, this.graphEditorInputMode,
                                                this.defaultLayouter, this.fileNamePathFolder, this.fileNamePath);
        mainMenuBar = menuBar.initMenuBar();

        JMenuItem springEmbedderItem = new JMenuItem();
        springEmbedderItem.setIcon(new ImageIcon(getClass().getResource("/resources/layout-16.png")));
        springEmbedderItem.setText("Spring Embedder");
        springEmbedderItem.addActionListener(this::springEmbedderItemActionPerformed);
        layoutMenu.add(springEmbedderItem);

        JMenuItem gridPositioningItem = new JMenuItem();
        gridPositioningItem.setIcon(new ImageIcon(getClass().getResource("/resources/layout-16.png")));
        gridPositioningItem.setText("Respective Crossing Angle Gridding");
        gridPositioningItem.addActionListener(this::gridCrossingItemActionPerformed);
        layoutMenu.add(gridPositioningItem);

        JMenuItem gridItem = new JMenuItem();
        gridItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, InputEvent.CTRL_MASK));
        gridItem.setIcon(new ImageIcon(getClass().getResource("/resources/grid-16.png")));
        gridItem.setText("Grid");
        gridItem.addActionListener(this::gridItemActionPerformed);
        viewMenu.add(gridItem);

        JMenu analyzeMenu = new JMenu();
        analyzeMenu.setIcon(new ImageIcon(getClass().getResource("/resources/star-16.png")));
        analyzeMenu.setText("Analyze Graph");

        JMenuItem minimumCrossingAngleMenu = new JMenuItem();
        minimumCrossingAngleMenu.setIcon(new ImageIcon(getClass().getResource("/resources/star-16.png")));
        minimumCrossingAngleMenu.setText("Minimum Angle");
        minimumCrossingAngleMenu.addActionListener(this::minimumCrossingAngleMenuActionPerformed);
        analyzeMenu.add(minimumCrossingAngleMenu);
        viewMenu.add(analyzeMenu);
        viewMenu.add(new JSeparator());

        mainMenuBar.add(layoutMenu);
        super.setJMenuBar(mainMenuBar);
    }


    /*********************************************************************
     * Popup Menus
     ********************************************************************/
    private void populateEdgePopupMenu(PopulateItemPopupMenuEventArgs<IModelItem> args) {
        ISelectionModel<IEdge> selection = this.view.getSelection().getSelectedEdges();
        if (args.getItem() instanceof IEdge) {
            IEdge edge = (IEdge) args.getItem();
            selection.clear();
            selection.setSelected(edge, true);
            this.view.setCurrentItem(edge);

            JPopupMenu popupMenu = (JPopupMenu) args.getMenu();

            javax.swing.JMenuItem removeVertex = new javax.swing.JMenuItem("Delete");
            removeVertex.setIcon(new ImageIcon(getClass().getResource("/resources/delete-16.png")));
            removeVertex.addActionListener(evt -> {
                graph.remove(edge);
                view.updateUI();
            });

            popupMenu.add(removeVertex);
            args.setHandled(true);
        }
    }

    private void populateNodePopupMenu(PopulateItemPopupMenuEventArgs<IModelItem> args) {
        ISelectionModel<INode> selection = this.view.getSelection().getSelectedNodes();
        if (args.getItem() instanceof INode) {
            INode node = (INode) args.getItem();
            selection.clear();
            selection.setSelected(node, true);
            this.view.setCurrentItem(node);

            JPopupMenu popupMenu = (JPopupMenu) args.getMenu();

            JMenuItem editLabel = new JMenuItem(node.getLabels().first().getText().equals("") ? "Add Label" : "Edit Label");
            editLabel.setIcon(new ImageIcon(getClass().getResource("/resources/star-16.png")));
            editLabel.addActionListener(evt -> {
                JTextField labelTextField = new JTextField(node.getLabels().first().getText());
                int result = JOptionPane.showOptionDialog(null, new Object[]{"Label: ", labelTextField}, node.getLabels().first().getText().equals("") ? "Add Label" : "Edit Label", JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);
                if (result == JOptionPane.OK_OPTION) {
                    graph.setLabelText(node.getLabels().first(), labelTextField.getText());
                }
            });

            javax.swing.JMenuItem removeVertex = new javax.swing.JMenuItem("Delete");
            removeVertex.setIcon(new ImageIcon(getClass().getResource("/resources/delete-16.png")));
            removeVertex.addActionListener(evt -> {
                graph.remove(node);
                view.updateUI();
            });

            popupMenu.add(editLabel);
            popupMenu.add(removeVertex);
            args.setHandled(true);
        }
    }

    /*********************************************************************
     * Implementation of actions
     ********************************************************************/
    private void gridCrossingItemActionPerformed(ActionEvent evt) {
        if(ForceAlgorithmApplier.class != null) {
            GridPositioning grid = new GridPositioning(this.graph);
            if (!grid.isGridded(this.graph)) {
                ForceAlgorithmApplier.applyNodePositionsToGraph(this.graph, grid.getGridNodesRespectively());
            }
        }
    }

    final Double[] springThreshholds = new Double[]{0.01, 0.01, 0.01, 0.1};
    final Boolean[] algoModifiers = new Boolean[]{false, false};

    private void springEmbedderItemActionPerformed(ActionEvent evt) {
        JTextField iterationsTextField = new JTextField("1000");
        int iterations = 1000;

        int result = JOptionPane.showOptionDialog(null, new Object[]{"Number of Iterations: ", iterationsTextField}, "Algorithm Properties", JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);

        if (result == JOptionPane.OK_OPTION) {
            try {
                iterations = Integer.parseInt(iterationsTextField.getText());
            } catch (NumberFormatException exc) {
                JOptionPane.showMessageDialog(null, "Incorrect input.\nThe number of iterations will be set to 5000.", "Incorrect Input", JOptionPane.ERROR_MESSAGE);
            }
        }
        else return;

        ForceAlgorithmApplier fd = defaultForceAlgorithmApplier(iterations);
        MainFrame.finalizeFAA.accept(faa);
        faa = Maybe.just(fd);


        Thread thread = new Thread(fd);
        thread.start();
        this.view.updateUI();
    }

    private void gridItemActionPerformed(ActionEvent evt) {
        if (this.isGridVisible) {
            this.isGridVisible = false;
            this.graphSnapContext.setGridSnapType(GridSnapTypes.NONE);
        } else {
            this.isGridVisible = true;
            this.graphSnapContext.setGridSnapType(GridSnapTypes.GRID_POINTS);
        }
        this.gridVisualCreator.setVisible(this.isGridVisible);
        this.view.updateUI();
    }

    private void minimumCrossingAngleMenuActionPerformed(ActionEvent evt){
        Maybe<Tuple3<LineSegment, LineSegment, Intersection>>
                minAngleCr = MinimumAngle.getMinimumAngleCrossing(graph, Maybe.nothing());
        Maybe<String> labText = minAngleCr.fmap(cr -> {
            String text = "Minimum Angle: " + cr.c.angle.toString();
            if(cr.a.n1.hasValue() && cr.b.n1.hasValue()){
                text += " | Nodes: " + cr.a.n1.get().getLabels().first().getText();
                text += " , " +  cr.a.n2.get().getLabels().first().getText();
                text += " | " +  cr.b.n1.get().getLabels().first().getText();
                text += " , " +  cr.b.n2.get().getLabels().first().getText();
            }
            MinimumAngle.resetHighlighting(this.graph);
            MinimumAngle.highlightCrossing(cr);
            view.updateUI();
            return text;
        });
        infoLabel.setText(labText.getDefault("Graph has no crossings."));
    }


    private ForceAlgorithmApplier defaultForceAlgorithmApplier(int iterations){

        ForceAlgorithmApplier fd = new ForceAlgorithmApplier(view, iterations, Maybe.just(progressBar), Maybe.just(infoLabel));
        fd.modifiers = springThreshholds.clone();
        fd.switches = algoModifiers.clone();
        fd.algos.add(new NodePairForce(p1 -> (p2 -> {
            double electricalRepulsion = 50000,
                   threshold = fd.modifiers[0];
            PointD t = PointD.subtract(p1, p2);
            double dist = t.getVectorLength();
            if(dist <= Epsilon){
                return new PointD(0, 0);
            }
            t = PointD.div(t, dist);
            t = PointD.times(threshold * electricalRepulsion / Math.pow(dist, 2), t);
            return t;
        })));
        fd.algos.add(new NodeNeighbourForce(p1 -> (p2 -> {
            double springStiffness = 150,
                   springNaturalLength = 100,
                   threshold = fd.modifiers[1];
            PointD t = PointD.subtract(p2, p1);
            double dist = t.getVectorLength();
            if(dist <= Epsilon){
                return new PointD(0, 0);
            }
            t = PointD.div(t, dist);
            //t = PointD.times(threshold * springStiffness * Math.log(dist / springNaturalLength), t);
            t = PointD.times(t, threshold * (dist - springNaturalLength));
            return t;
        })));

        fd.algos.add(new CrossingForce(e1 -> (e2 -> (angle -> {
            double threshold = fd.modifiers[2];
            if(e1.getVectorLength() <= Epsilon ||
               e2.getVectorLength() <= Epsilon){
                return new Tuple2<>(new PointD(0, 0), new PointD(0, 0));
            }
            PointD t1 = e1.getNormalized();
            PointD t2 = e2.getNormalized();
            PointD t1Neg = PointD.negate(t1);
            PointD t2Neg = PointD.negate(t2);
            PointD t1_ = new PointD(0,0),
                   t2_ = new PointD(0,0);

            t1_ = PointD.times(t2Neg, threshold * Math.cos(Math.toRadians(angle)));
            t2_ = PointD.times(t1Neg, threshold * Math.cos(Math.toRadians(angle)));
            t1 = PointD.times(t1, threshold * Math.cos(Math.toRadians(angle)));
            t2 = PointD.times(t2, threshold * Math.cos(Math.toRadians(angle)));

            t1 = rotate.apply(PointD.negate(t1));
            t2 = rotate.apply(t2);
            // if(perpendicular?)
            if(fd.switches[0]) {  
                return new Tuple2<>(t1, t2);
            }
            // else direction of other edge
            else{
                return new Tuple2<>(t1_, t2_);
            }
            /*if(angle > 60 && angle < 120){
                return new Tuple2<>(new PointD(0, 0), new PointD(0, 0));
            }
            t1 = PointD.times(t1, threshold * Math.cos(2.0 / 3.0 * Math.toRadians(angle)));
            t2 = PointD.times(t2, threshold * Math.cos(2.0 / 3.0 * Math.toRadians(angle)));
		*/
       
        }))));

        fd.algos.add(new IncidentEdgesForce(e1 -> (e2 -> (angle -> (deg -> {
            if(deg <= 0) return new Tuple2<>(new PointD(0, 0), new PointD(0, 0));
            double threshold = fd.modifiers[3],
                    optAngle = (360 / deg);
            if(e1.getVectorLength() <= Epsilon ||
               e2.getVectorLength() <= Epsilon){
                return new Tuple2<>(new PointD(0, 0), new PointD(0, 0));
            }
            PointD t1 = e1.getNormalized();
            PointD t2 = e2.getNormalized();
            Double neg = Math.signum(angle);

            t1 = PointD.times(t1, neg * threshold * Math.sin((Math.toRadians(optAngle - Math.abs(angle)))/2.0));
            t2 = PointD.times(t2, neg * threshold * Math.sin((Math.toRadians(optAngle - Math.abs(angle)))/2.0));
            t1 = rotate.apply(t1);
            t2 = PointD.negate(t2);
            t2 = rotate.apply(t2);
            return new Tuple2<>(t1, t2);
        })))));
        return fd;
    }

    private void forceDirectionPerpendicularActionPerformed(ActionEvent evt){    this.algoModifiers[0] = true; }
    private void forceDirectionNonPerpendicularActionPerformed(ActionEvent evt){ this.algoModifiers[0] = false; }

    private void optimizingAngleNintyActionPerformed(ActionEvent actionEvent) { this.algoModifiers[1] = true; }
    private void optimizingAngleSixtyActionPerformed(ActionEvent actionEvent) { this.algoModifiers[1] = false; }



    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        try {
            // check for 'os.name == Windows 7' does not work, since JDK 1.4 uses the compatibility mode
            if (!"com.sun.java.swing.plaf.motif.MotifLookAndFeel".equals(UIManager.getSystemLookAndFeelClassName()) && !"com.sun.java.swing.plaf.gtk.GTKLookAndFeel".equals(UIManager.getSystemLookAndFeelClassName()) && !UIManager.getSystemLookAndFeelClassName().equals(UIManager.getLookAndFeel().getClass().getName()) && !(System.getProperty("java.version").startsWith("1.4") && System.getProperty("os.name").startsWith("Windows") && "6.1".equals(System.getProperty("os.version")))) {
                UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(() -> new MainFrame().setVisible(true));
    }


}
