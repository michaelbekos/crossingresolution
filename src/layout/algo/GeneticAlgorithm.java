package layout.algo;

import com.sun.istack.internal.Nullable;
import util.*;

import java.util.*;
import java.util.stream.*;
import java.util.function.*;

import javax.swing.*;


public class GeneticAlgorithm<T> implements Runnable {
  public static Random rand = new Random();

  public List<T> instances = new LinkedList<T>();
  public int desiredInstanceCount;
  Comparator<T> scoring;
  Function<List<T>, T> generator;
  Function<T, T> advance;
  public boolean running = false;
  @Nullable
  public Consumer<T> bestChanged;

  /* GeneticAlgorithm: keeps a set of instances T. Each iteration, Ts live/advance, some die, some reproduce.
   * adv:       Function to advance a T (~ "time passes" for each t ∈ T)
   * sf:        Comparator to score Ts. Is used to sort all instances in the current generation and determine the worst instances.
   * desiredIC: An integer specifying how many instances should be alive at any time. If zero is supplied, the algorithm just keeps the set of instances at a constant size.
   * gen:       A function to generate new instances. Is either:
   *            - a function taking a T and producing a mutated T out of that
   *            - a function taking all Ts and mutating some to produce a new T
   *            If the first one is supplied, a function of the latter type is generated by choosing an element in the current generation at random, then using the supplied function.
   * ---------
   * All above functions should be relatively pure.
   */

  public GeneticAlgorithm(Function<T, T> adv, Comparator<T> sf, int desiredIC, Either<Function<T, T>, Function<List<T>, T>> gen){
    advance = adv;
    scoring = sf;
    desiredInstanceCount = desiredIC;
    instances = new ArrayList<>(desiredInstanceCount);
    generator = gen.match(
      left -> (l -> {
        int listElemIndex = rand.nextInt(l.size());
        T listElem = l.get(listElemIndex);
        return left.apply(listElem);
      }), 
      right -> right);
  }

  /* runRound: let time pass once */
  public void runRound(){
    assertInstances();
    instances = instances
      .parallelStream()
      .map(i -> advance.apply(i))
      .collect(Collectors.toList());
  }
  /* assertInstances: produce instances until at least desiredInstanceCount is alive. Check if at least one instance exists. */
  public void assertInstances(){
    if (desiredInstanceCount > 0) {
      while(instances.size() < desiredInstanceCount){
        newInstance();
      }
    }
    if(instances.isEmpty()){
      throw new IllegalStateException();
    }
  }
  /* newInstance: spawn a new instance using generator :: [T] -> T  and add it. */
  public void newInstance(){
    T newInstance = generator.apply(instances);
    for(int i = 0; i < 10; i++){
      newInstance = advance.apply(newInstance);
    }
    instances.add(newInstance);
  }
  /* nextGeneration: do
   *   check if everything's ok
   *   kill the worst {2} instances
   *   spawn {2} new instances
   */
  public void nextGeneration(){
    assertInstances();
    Collections.sort(instances, scoring);
    // instances is not empty, since (assertInstances)
    for(int i = 0; i < 2; i++){
      instances.remove(0);
      newInstance();  
    }
  }
  /* notifyChanged: If there is a handler for nextInstance, produce to it the best instance. */
  private void notifyChanged(){
    if (bestChanged != null) {
      Collections.sort(instances, scoring);
      bestChanged.accept(instances.get(instances.size() - 1));
    }
  }
  /* runRounds: run the specified number of rounds, i.e. iterate(). */
  public void runRounds(int count){
    running = true;
    for(int i = 0; i < count && running; i++){
      iterate();
    } 
  }
  /* iterate: let time pass, mutate, notify. */
  public void iterate(){
    runRound();
    nextGeneration();
    notifyChanged();
  }
  /* runIndefinitely ≃ runRounds ∞, until !running */
  public void runIndefinitely(){
    running = true;
    while(running){
      iterate();
      try {
        Thread.sleep(1);
      } catch (InterruptedException exc) {
        System.out.println("Sleep interrupted!");
        //Do nothing...
      }
      
    }
  }
  /* for Thread.run() */
  public void run(){
    runIndefinitely();
  }
}